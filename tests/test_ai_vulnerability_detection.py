"""
Unit tests for AI-powered vulnerability detection.
"""

import pytest
from unittest.mock import Mock, patch
from typing import Dict, Any, List

# Import the modules to test
import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'bac_hunter'))

from bac_hunter.intelligence.ai.enhanced_detection import (
    IntelligentVulnerabilityDetector, VulnerabilityType, ConfidenceLevel,
    VulnerabilityFinding, VulnerabilityEvidence, ContextualAnalyzer,
    detect_vulnerabilities_with_ai, generate_vulnerability_report
)


class TestIntelligentVulnerabilityDetector:
    """Test the AI vulnerability detection system."""
    
    @pytest.fixture
    def detector(self):
        """Create a vulnerability detector for testing."""
        return IntelligentVulnerabilityDetector()
        
    @pytest.fixture
    def sample_responses(self):
        """Create sample HTTP responses for testing."""
        return [
            {
                'url': 'https://api.example.com/users/123',
                'status_code': 200,
                'headers': {'content-type': 'application/json'},
                'body': '{"user_id": 123, "email": "john@example.com", "name": "John Doe"}',
                'request_headers': {'Authorization': 'Bearer token123'}
            },
            {
                'url': 'https://api.example.com/users/456',
                'status_code': 200,
                'headers': {'content-type': 'application/json'},
                'body': '{"user_id": 456, "email": "jane@example.com", "name": "Jane Smith"}',
                'request_headers': {'Authorization': 'Bearer token456'}
            },
            {
                'url': 'https://api.example.com/admin/dashboard',
                'status_code': 200,
                'headers': {'content-type': 'text/html'},
                'body': '<html><body><h1>Admin Dashboard</h1><p>Welcome administrator</p></body></html>',
                'request_headers': {'Cookie': 'session=user123'}
            }
        ]
        
    def test_initialization(self, detector):
        """Test detector initialization."""
        assert detector.response_patterns is not None
        assert detector.behavioral_patterns is not None
        assert detector.context_analyzer is not None
        assert isinstance(detector.findings_cache, dict)
        
    def test_pattern_building(self, detector):
        """Test that vulnerability patterns are properly built."""
        # Check IDOR patterns
        assert VulnerabilityType.IDOR in detector.response_patterns
        idor_patterns = detector.response_patterns[VulnerabilityType.IDOR]
        assert len(idor_patterns) > 0
        
        # Check pattern structure
        pattern = idor_patterns[0]
        assert 'name' in pattern
        assert 'confidence' in pattern
        assert 'description' in pattern
        
    def test_url_pattern_extraction(self, detector):
        """Test URL pattern extraction."""
        test_cases = [
            ('https://api.example.com/users/123', 'https://api.example.com/users/ID'),
            ('https://api.example.com/docs/550e8400-e29b-41d4-a716-446655440000', 
             'https://api.example.com/docs/UUID'),
            ('https://api.example.com/search?q=test&page=1', 
             'https://api.example.com/search?PARAMS')
        ]
        
        for url, expected_pattern in test_cases:
            pattern = detector._extract_url_pattern(url)
            assert pattern == expected_pattern
            
    def test_response_grouping(self, detector, sample_responses):
        """Test grouping of responses by URL patterns."""
        groups = detector._group_responses_by_pattern(sample_responses)
        
        assert len(groups) >= 2  # Should have at least user and admin groups
        assert 'https://api.example.com/users/ID' in groups
        
    def test_user_identity_extraction(self, detector):
        """Test extraction of user identity from responses."""
        response_with_auth = {
            'request_headers': {'Authorization': 'Bearer token123'}
        }
        
        response_with_cookie = {
            'request_headers': {'Cookie': 'session=user456'}
        }
        
        response_anonymous = {
            'request_headers': {}
        }
        
        # Should extract different identities
        id1 = detector._extract_user_identity(response_with_auth, None)
        id2 = detector._extract_user_identity(response_with_cookie, None)
        id3 = detector._extract_user_identity(response_anonymous, None)
        
        assert id1 != id2
        assert id3 == 'anonymous'
        
    def test_url_similarity_calculation(self, detector):
        """Test URL similarity calculation."""
        # Similar URLs
        url1 = 'https://api.example.com/users/123'
        url2 = 'https://api.example.com/users/456'
        similarity = detector._calculate_url_similarity(url1, url2)
        assert similarity > 0.8
        
        # Different URLs
        url3 = 'https://api.example.com/posts/123'
        similarity = detector._calculate_url_similarity(url1, url3)
        assert similarity < 0.8
        
    def test_content_similarity_calculation(self, detector):
        """Test content similarity calculation."""
        content1 = "user id 123 email john@example.com name John"
        content2 = "user id 456 email jane@example.com name Jane"
        
        similarity = detector._calculate_content_similarity(content1, content2)
        assert 0.3 < similarity < 0.9  # Some similarity but not identical
        
    def test_content_analysis_for_user_data(self, detector):
        """Test analysis of user-specific data in content."""
        resp_a = {
            'url': 'https://api.example.com/users/123',
            'body': '{"user_id": 123, "email": "john@example.com"}'
        }
        
        resp_b = {
            'url': 'https://api.example.com/users/456',
            'body': '{"user_id": 456, "email": "jane@example.com"}'
        }
        
        analysis = detector._analyze_content_for_user_data(resp_a, resp_b)
        
        assert 'suggests_cross_access' in analysis
        assert 'data_a' in analysis
        assert 'data_b' in analysis
        assert 'content_similarity' in analysis
        
    def test_id_pattern_analysis(self, detector):
        """Test analysis of ID patterns for predictability."""
        # Sequential ID responses
        responses = [
            {'url': f'https://api.example.com/users/{i}', 'body': f'{{"id": {i}}}'} 
            for i in range(1, 11)
        ]
        
        findings = detector._analyze_id_patterns(responses)
        
        assert len(findings) > 0
        assert findings[0].type == VulnerabilityType.IDOR
        assert 'sequential' in findings[0].title.lower()
        
    def test_cross_user_access_detection(self, detector):
        """Test detection of cross-user access."""
        responses_a = [
            {
                'url': 'https://api.example.com/profile/123',
                'status_code': 200,
                'body': '{"user_id": 123, "name": "John"}'
            }
        ]
        
        responses_b = [
            {
                'url': 'https://api.example.com/profile/456', 
                'status_code': 200,
                'body': '{"user_id": 456, "name": "Jane"}'
            }
        ]
        
        findings = detector._detect_cross_user_access(responses_a, responses_b)
        
        if findings:  # May not always detect based on similarity threshold
            assert findings[0].type == VulnerabilityType.IDOR
            assert findings[0].confidence in [ConfidenceLevel.HIGH, ConfidenceLevel.MEDIUM]
            
    def test_privilege_escalation_analysis(self, detector):
        """Test privilege escalation vulnerability analysis."""
        responses = [
            {
                'url': 'https://api.example.com/admin/dashboard',
                'status_code': 200,
                'body': '<html><h1>Admin Dashboard</h1><p>administrator privileges</p></html>'
            }
        ]
        
        findings = detector._analyze_privilege_escalation(responses, None)
        
        assert len(findings) > 0
        assert findings[0].type == VulnerabilityType.PRIVILEGE_ESCALATION
        assert findings[0].severity == 'high'
        
    def test_information_disclosure_analysis(self, detector):
        """Test information disclosure vulnerability analysis."""
        responses = [
            {
                'url': 'https://api.example.com/config',
                'status_code': 200,
                'headers': {'content-type': 'application/json'},
                'body': '{"database": "mysql://user:password@localhost", "secret_key": "abc123"}'
            }
        ]
        
        findings = detector._analyze_information_disclosure(responses, None)
        
        assert len(findings) > 0
        assert findings[0].type == VulnerabilityType.INFORMATION_DISCLOSURE
        
    def test_behavioral_anomaly_analysis(self, detector):
        """Test behavioral anomaly analysis."""
        # Responses with mixed status codes (anomalous pattern)
        responses = [
            {'url': 'https://api.example.com/test1', 'status_code': 200},
            {'url': 'https://api.example.com/test2', 'status_code': 403},
            {'url': 'https://api.example.com/test3', 'status_code': 200},
            {'url': 'https://api.example.com/test4', 'status_code': 403},
            {'url': 'https://api.example.com/test5', 'status_code': 200}
        ]
        
        findings = detector._analyze_behavioral_anomalies(responses, None)
        
        if findings:  # May not always detect based on thresholds
            assert findings[0].type == VulnerabilityType.AUTHORIZATION_BYPASS
            
    def test_status_code_pattern_analysis(self, detector):
        """Test status code pattern analysis."""
        # High mix of success and forbidden
        status_codes = [200, 200, 403, 403, 200, 403]
        
        analysis = detector._analyze_status_code_patterns(status_codes)
        
        assert 'anomaly_detected' in analysis
        assert 'success_rate' in analysis
        assert 'forbidden_rate' in analysis
        assert analysis['total_responses'] == 6
        
    def test_finding_deduplication(self, detector):
        """Test deduplication of similar findings."""
        findings = [
            VulnerabilityFinding(
                id='test1', type=VulnerabilityType.IDOR, confidence=ConfidenceLevel.HIGH,
                severity='high', title='Test', description='Test', evidence=[],
                affected_urls=[], recommendations=[]
            ),
            VulnerabilityFinding(
                id='test1', type=VulnerabilityType.IDOR, confidence=ConfidenceLevel.HIGH,
                severity='high', title='Test', description='Test', evidence=[],
                affected_urls=[], recommendations=[]
            ),  # Duplicate
            VulnerabilityFinding(
                id='test2', type=VulnerabilityType.IDOR, confidence=ConfidenceLevel.MEDIUM,
                severity='medium', title='Test2', description='Test2', evidence=[],
                affected_urls=[], recommendations=[]
            )
        ]
        
        deduplicated = detector._deduplicate_findings(findings)
        
        assert len(deduplicated) == 2
        assert deduplicated[0].id != deduplicated[1].id
        
    def test_context_enhancement(self, detector):
        """Test enhancement of findings with context."""
        findings = [
            VulnerabilityFinding(
                id='test1', type=VulnerabilityType.IDOR, confidence=ConfidenceLevel.MEDIUM,
                severity='medium', title='Test', description='Test', evidence=[],
                affected_urls=[], recommendations=[]
            )
        ]
        
        context = {
            'environment': 'production',
            'application_type': 'financial'
        }
        
        enhanced = detector._enhance_with_context(findings, context)
        
        # Severity should be increased for production financial app
        assert enhanced[0].severity == 'high'
        assert 'financial' in enhanced[0].recommendations[0].lower()
        
    def test_finding_id_generation(self, detector):
        """Test unique finding ID generation."""
        id1 = detector._generate_finding_id('idor', 'https://example.com/test')
        id2 = detector._generate_finding_id('idor', 'https://example.com/other')
        id3 = detector._generate_finding_id('privilege', 'https://example.com/test')
        
        # All should be different
        assert id1 != id2
        assert id1 != id3
        assert id2 != id3
        
        # Should be consistent for same inputs
        id1_again = detector._generate_finding_id('idor', 'https://example.com/test')
        # Note: includes timestamp so will be different
        assert len(id1) == len(id1_again)  # Same format
        
    def test_comprehensive_analysis(self, detector, sample_responses):
        """Test comprehensive vulnerability analysis."""
        context = {
            'application_type': 'api',
            'environment': 'production'
        }
        
        findings = detector.analyze_responses(sample_responses, context)
        
        # Should return a list of findings
        assert isinstance(findings, list)
        
        # Each finding should have proper structure
        for finding in findings:
            assert isinstance(finding, VulnerabilityFinding)
            assert finding.id is not None
            assert finding.type in VulnerabilityType
            assert finding.confidence in ConfidenceLevel
            assert finding.severity in ['low', 'medium', 'high', 'critical']
            assert isinstance(finding.evidence, list)
            assert isinstance(finding.affected_urls, list)
            assert isinstance(finding.recommendations, list)


class TestContextualAnalyzer:
    """Test the contextual analyzer."""
    
    @pytest.fixture
    def analyzer(self):
        """Create a contextual analyzer."""
        return ContextualAnalyzer()
        
    def test_application_context_analysis(self, analyzer):
        """Test application context analysis."""
        responses = [
            {
                'url': 'https://api.bank.com/accounts',
                'headers': {'Server': 'nginx'},
                'body': 'Welcome to our banking application'
            },
            {
                'url': 'https://api.bank.com/api/transfers',
                'headers': {'Server': 'nginx'},
                'body': 'Financial transaction data'
            }
        ]
        
        context = analyzer.analyze_application_context(responses)
        
        assert context['application_type'] == 'financial'
        assert context['api_style'] == 'rest'
        
    def test_framework_detection(self, analyzer):
        """Test web framework detection."""
        responses = [
            {
                'url': 'https://example.com',
                'headers': {'Server': 'gunicorn/20.1.0'},
                'body': 'Django application content'
            }
        ]
        
        context = analyzer.analyze_application_context(responses)
        assert context['framework'] == 'django'
        
    def test_api_style_detection(self, analyzer):
        """Test API style detection."""
        responses = [
            {
                'url': 'https://api.example.com/graphql',
                'headers': {},
                'body': 'GraphQL endpoint'
            }
        ]
        
        context = analyzer.analyze_application_context(responses)
        assert context['api_style'] == 'graphql'


class TestHelperFunctions:
    """Test helper functions."""
    
    def test_detect_vulnerabilities_with_ai(self, sample_responses):
        """Test main vulnerability detection function."""
        context = {'application_type': 'api'}
        
        findings = detect_vulnerabilities_with_ai(sample_responses, context)
        
        assert isinstance(findings, list)
        # May or may not find vulnerabilities depending on detection thresholds
        
    def test_generate_vulnerability_report_empty(self):
        """Test vulnerability report generation with no findings."""
        report = generate_vulnerability_report([])
        
        assert report['total_findings'] == 0
        assert report['severity_breakdown'] == {}
        assert 'No vulnerabilities detected' in report['summary']
        
    def test_generate_vulnerability_report_with_findings(self):
        """Test vulnerability report generation with findings."""
        findings = [
            VulnerabilityFinding(
                id='test1', type=VulnerabilityType.IDOR, confidence=ConfidenceLevel.HIGH,
                severity='high', title='IDOR Test', description='Test IDOR', evidence=[],
                affected_urls=['https://example.com/test'], recommendations=['Fix IDOR'],
                cwe_id='CWE-639'
            ),
            VulnerabilityFinding(
                id='test2', type=VulnerabilityType.PRIVILEGE_ESCALATION, 
                confidence=ConfidenceLevel.CRITICAL, severity='critical', 
                title='Privilege Escalation', description='Test privilege escalation', 
                evidence=[], affected_urls=['https://example.com/admin'], 
                recommendations=['Fix privileges'], cwe_id='CWE-269'
            )
        ]
        
        report = generate_vulnerability_report(findings)
        
        assert report['total_findings'] == 2
        assert report['severity_breakdown']['high'] == 1
        assert report['severity_breakdown']['critical'] == 1
        assert report['risk_score'] > 0
        assert len(report['findings']) == 2
        
        # Check finding structure in report
        finding_report = report['findings'][0]
        assert 'id' in finding_report
        assert 'type' in finding_report
        assert 'confidence' in finding_report
        assert 'severity' in finding_report
        assert 'title' in finding_report
        assert 'affected_urls' in finding_report
        assert 'recommendations' in finding_report
        assert 'cwe_id' in finding_report


class TestVulnerabilityDataClasses:
    """Test vulnerability data classes."""
    
    def test_vulnerability_evidence_creation(self):
        """Test creation of vulnerability evidence."""
        evidence = VulnerabilityEvidence(
            type='test_evidence',
            description='Test evidence description',
            data={'key': 'value'},
            confidence=0.8
        )
        
        assert evidence.type == 'test_evidence'
        assert evidence.description == 'Test evidence description'
        assert evidence.data == {'key': 'value'}
        assert evidence.confidence == 0.8
        
    def test_vulnerability_finding_creation(self):
        """Test creation of vulnerability finding."""
        evidence = VulnerabilityEvidence('test', 'desc', {}, 0.8)
        
        finding = VulnerabilityFinding(
            id='test_finding',
            type=VulnerabilityType.IDOR,
            confidence=ConfidenceLevel.HIGH,
            severity='high',
            title='Test Finding',
            description='Test description',
            evidence=[evidence],
            affected_urls=['https://example.com'],
            recommendations=['Fix this'],
            cwe_id='CWE-639',
            cvss_score=7.5
        )
        
        assert finding.id == 'test_finding'
        assert finding.type == VulnerabilityType.IDOR
        assert finding.confidence == ConfidenceLevel.HIGH
        assert finding.severity == 'high'
        assert len(finding.evidence) == 1
        assert len(finding.affected_urls) == 1
        assert len(finding.recommendations) == 1
        assert finding.cwe_id == 'CWE-639'
        assert finding.cvss_score == 7.5


class TestVulnerabilityTypeEnum:
    """Test vulnerability type enum."""
    
    def test_vulnerability_types(self):
        """Test that all expected vulnerability types exist."""
        expected_types = [
            'idor', 'privilege_escalation', 'horizontal_access', 'vertical_access',
            'authentication_bypass', 'authorization_bypass', 'session_fixation',
            'csrf', 'information_disclosure'
        ]
        
        actual_types = [vt.value for vt in VulnerabilityType]
        
        for expected in expected_types:
            assert expected in actual_types


class TestConfidenceLevelEnum:
    """Test confidence level enum."""
    
    def test_confidence_levels(self):
        """Test that all expected confidence levels exist."""
        expected_levels = ['low', 'medium', 'high', 'critical']
        
        actual_levels = [cl.value for cl in ConfidenceLevel]
        
        for expected in expected_levels:
            assert expected in actual_levels